// RUN: %target-sil-opt %s -compute-effects | %FileCheck %s

sil_stage canonical

import Builtin
import Swift
import SwiftShims

protocol ClassP : AnyObject {
  func foo()
}

class X : ClassP {
  func foo()
  deinit
}

class Derived : X {
}

struct Str {
  @_hasStorage var a: X
  @_hasStorage var b: (X, X)
}

class Y {
  @_hasStorage var s: Str
}

class Z {
  @_hasStorage var y: Y
}

class DerivedZ : Z {
}

class LinkedNode {
  @_hasStorage var next: LinkedNode;
  @_hasStorage var x: X;
}

enum E {
  case A(Z)
  case B(Z)
}

sil [ossa] @unknown_function : $@convention(thin) (@owned X) -> ()
sil [ossa] @unknown_function_y : $@convention(thin) (@owned Y) -> ()

// CHECK-LABEL: sil [+escapes_to_argument3(1, *), +noescape(2, *), +noescape(3, **)] [ossa] @test_simple
sil [ossa] @test_simple : $@convention(thin) (@owned X, @guaranteed Str, @guaranteed Z, @inout X) -> @owned Y {
bb0(%0 : @owned $X, %1 : @guaranteed $Str, %2 : @guaranteed $Z, %3 : $*X):
  // %0 escapes to global
  %4 = function_ref @unknown_function : $@convention(thin) (@owned X) -> ()
  %5 = apply %4(%0) : $@convention(thin) (@owned X) -> ()
  
  // %1 escapes to argument %3
  %6 = struct_extract %1 : $Str, #Str.a
  %7 = copy_value %6 : $X
  store %7 to [assign] %3 : $*X

  // content of %2 escapes to return
  // %2 does not escape
  %8 = ref_element_addr %2 : $Z, #Z.y
  %9 = load [copy] %8 : $*Y
  return %9 : $Y
}

// CHECK-LABEL: sil [+noescape(0, *)] [ossa] @test_escaping_content
sil [ossa] @test_escaping_content : $@convention(thin) (@guaranteed Z) -> () {
bb0(%0 : @guaranteed $Z):
  %1 = ref_element_addr %0 : $Z, #Z.y
  %2 = load [copy] %1 : $*Y
  %3 = function_ref @unknown_function_y : $@convention(thin) (@owned Y) -> ()
  %4 = apply %3(%2) : $@convention(thin) (@owned Y) -> ()
  %5 = tuple ()
  return %5 : $()
}


sil [escapes_to_argument0(0, *)] [ossa] @self_arg_callee : $@convention(thin) (@inout X) -> ()

// CHECK-LABEL: sil [+escapes_to_argument0(0, *)] [ossa] @test_self_arg_escape
sil [ossa] @test_self_arg_escape : $@convention(thin) (@inout X) -> () {
bb0(%0 : $*X):
  %1 = function_ref @self_arg_callee : $@convention(thin) (@inout X) -> ()
  %2 = apply %1(%0) : $@convention(thin) (@inout X) -> ()
  %3 = tuple ()
  return %3 : $()
}


