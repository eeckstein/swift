// RUN: %target-sil-opt %s -compute-effects | %FileCheck %s

sil_stage canonical

import Builtin
import Swift
import SwiftShims

protocol ClassP : AnyObject {
  func foo()
}

class X : ClassP {
  func foo()
  deinit
}

class Derived : X {
}

struct Str {
  @_hasStorage var a: X
  @_hasStorage var b: (X, X)
}

class Y {
  @_hasStorage var s: Str
}

class Z {
  @_hasStorage var y: Y
}

class DerivedZ : Z {
}

class LinkedNode {
  @_hasStorage var next: LinkedNode;
  @_hasStorage var x: X;
}

enum E {
  case A(Z)
  case B(Z)
}

sil [ossa] @unknown_function : $@convention(thin) (@owned X) -> ()
sil [ossa] @unknown_function_y : $@convention(thin) (@owned Y) -> ()

// CHECK-LABEL: sil [+escaping(arg1, to: arg3), +notEscaping(arg2), +escaping(arg2.*, to: return), +notEscaping(arg3)] [ossa] @test_simple
sil [ossa] @test_simple : $@convention(thin) (@owned X, @guaranteed Str, @guaranteed Z, @inout X) -> @owned Y {
bb0(%0 : @owned $X, %1 : @guaranteed $Str, %2 : @guaranteed $Z, %3 : $*X):
  // %0 escapes to global
  %4 = function_ref @unknown_function : $@convention(thin) (@owned X) -> ()
  %5 = apply %4(%0) : $@convention(thin) (@owned X) -> ()
  
  // %1 escapes to argument %3
  %6 = struct_extract %1 : $Str, #Str.a
  %7 = copy_value %6 : $X
  store %7 to [assign] %3 : $*X

  // content of %2 escapes to return
  // %2 does not escape
  %8 = ref_element_addr %2 : $Z, #Z.y
  %9 = load [copy] %8 : $*Y
  return %9 : $Y
}

// CHECK-LABEL: sil [+notEscaping(arg0)] [ossa] @test_escaping_content
sil [ossa] @test_escaping_content : $@convention(thin) (@guaranteed Z) -> () {
bb0(%0 : @guaranteed $Z):
  %1 = ref_element_addr %0 : $Z, #Z.y
  %2 = load [copy] %1 : $*Y
  %3 = function_ref @unknown_function_y : $@convention(thin) (@owned Y) -> ()
  %4 = apply %3(%2) : $@convention(thin) (@owned Y) -> ()
  %5 = tuple ()
  return %5 : $()
}

// CHECK-LABEL: sil [+notEscaping(arg0), +escaping(arg0.*, to: return), +notEscaping(arg1)] [ossa] @test_exclusive_escaping
sil [ossa] @test_exclusive_escaping : $@convention(thin) (@guaranteed Z, @owned Y) -> @owned Y {
bb0(%0 : @guaranteed $Z, %1 : @owned $Y):
  %2 = ref_element_addr %0 : $Z, #Z.y
  %3 = load [copy] %2 : $*Y
  destroy_value %1 : $Y
  return %3 : $Y
}

// CHECK-LABEL: sil [+notEscaping(arg0), +escaping(arg0.*, to: return, notExclusive), +escaping(arg1, to: return, notExclusive)] [ossa] @test_not_exclusive_escaping_through_phi
sil [ossa] @test_not_exclusive_escaping_through_phi : $@convention(thin) (@guaranteed Z, @owned Y) -> @owned Y {
bb0(%0 : @guaranteed $Z, %1 : @owned $Y):
  cond_br undef, bb1, bb2
bb1:
  %3 = ref_element_addr %0 : $Z, #Z.y
  %4 = load [copy] %3 : $*Y
  destroy_value %1 : $Y
  br bb3(%4 : $Y)
bb2:
  br bb3(%1 : $Y)

bb3(%7: @owned $Y):
  return %7 : $Y
}

// CHECK-LABEL: sil [+notEscaping(arg0), +escaping(arg0.*, to: return, notExclusive)] [ossa] @test_not_exclusive_through_store
sil [ossa] @test_not_exclusive_through_store : $@convention(thin) (@guaranteed Z, @owned Y) -> @owned Y {
bb0(%0 : @guaranteed $Z, %1 : @owned $Y):
  %2 = ref_element_addr %0 : $Z, #Z.y
  %3 = load [copy] %2 : $*Y
  store %1 to [assign] %2 : $*Y
  return %3 : $Y
}

sil [escaping(arg0, to: arg0)] [ossa] @self_arg_callee : $@convention(thin) (@inout X) -> ()

// CHECK-LABEL: sil [+escaping(arg0, to: arg0)] [ossa] @test_self_arg_escape
sil [ossa] @test_self_arg_escape : $@convention(thin) (@inout X) -> () {
bb0(%0 : $*X):
  %1 = function_ref @self_arg_callee : $@convention(thin) (@inout X) -> ()
  %2 = apply %1(%0) : $@convention(thin) (@inout X) -> ()
  %3 = tuple ()
  return %3 : $()
}

// CHECK-LABEL: sil [+notEscaping(arg0.**), +notEscaping(arg1), +escaping(arg1.*, to: arg0)] [ossa] @test_content_to_arg_addr
sil [ossa] @test_content_to_arg_addr : $@convention(thin) (@guaranteed Y) -> @out Str {
bb0(%0 : $*Str, %1 : @guaranteed $Y):
  %2 = ref_element_addr %1 : $Y, #Y.s
  %3 = begin_access [read] [dynamic] %2 : $*Str
  copy_addr %3 to [initialization] %0 : $*Str
  end_access %3 : $*Str
  %6 = tuple ()
  return %6 : $()
}

// CHECK-LABEL: sil [+escaping(arg0, to: return.0.s0.s0.s0.v*)] @array_adopt_storage
sil @array_adopt_storage : $@convention(thin) (@owned _ContiguousArrayStorage<Int>) -> (@owned Array<Int>, UnsafeMutablePointer<Int>) {
bb0(%0 : $_ContiguousArrayStorage<Int>):
  %3 = upcast %0 : $_ContiguousArrayStorage<Int> to $__ContiguousArrayStorageBase
  %12 = unchecked_ref_cast %0 : $_ContiguousArrayStorage<Int> to $Builtin.BridgeObject
  %13 = struct $_BridgeStorage<__ContiguousArrayStorageBase> (%12 : $Builtin.BridgeObject)
  %14 = struct $_ArrayBuffer<Int> (%13 : $_BridgeStorage<__ContiguousArrayStorageBase>)
  %15 = struct $Array<Int> (%14 : $_ArrayBuffer<Int>)
  %16 = ref_tail_addr %3 : $__ContiguousArrayStorageBase, $Int
  %17 = address_to_pointer %16 : $*Int to $Builtin.RawPointer
  %18 = struct $UnsafeMutablePointer<Int> (%17 : $Builtin.RawPointer)
  %19 = tuple (%15 : $Array<Int>, %18 : $UnsafeMutablePointer<Int>)
  return %19 : $(Array<Int>, UnsafeMutablePointer<Int>)
}

